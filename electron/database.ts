// electron/database.ts - D√úZELTƒ∞LMƒ∞≈û VERSƒ∞YON
import { app } from 'electron';
import path from 'path';
import fs from 'fs';

// ‚úÖ D√úZELTME 1: Import d√ºzeltildi
let aiServiceModule: any = null;

// Interface tanƒ±mlarƒ±
interface FileResult {
  path: string;
  file_size: number;
  indexed_date: string;
  content_hash?: string;
  file_type?: string;
  language?: string;
}

interface SearchResult {
  path: string;
  text: string;
  file_size?: number;
  indexed_date?: string;
  chunk_id?: string;
  type?: string;
  error?: string;
  relevance_score?: number;
  file_type?: string;
  language?: string;
}

interface DatabaseStats {
  total_files: number;
  total_chunks: number;
  last_updated: string;
  database_size: string;
  indexed_extensions: string[];
}

// Dinamik import i√ßin deƒüi≈ükenler
let Database: any;
let lancedb: any;

// Veritabanƒ± baƒülantƒ±larƒ±
let sqliteDb: any;
let vectorTable: any;
let isInitialized = false;

const DB_DIR = path.join(app.getPath('userData'), 'SingletonDB');
const SQLITE_PATH = path.join(DB_DIR, 'metadata.sqlite');
const BACKUP_DIR = path.join(DB_DIR, 'backups');

/**
 * ‚úÖ D√úZELTME 2: AI Service lazy loading
 */
async function getAIService() {
  if (!aiServiceModule) {
    try {
      const module = await import('./ai-service');
      aiServiceModule = module.aiService || module.default;
      console.log('‚úÖ AI Service loaded');
    } catch (error) {
      console.warn('‚ö†Ô∏è AI Service not available:', error);
      // Mock AI service
      aiServiceModule = {
        getEmbedding: async (text: string) => {
          // Basit hash-based embedding
          const hash = text.split('').reduce((a, b) => {
            a = ((a << 5) - a) + b.charCodeAt(0);
            return a & a;
          }, 0);
          return Array(768).fill(0).map((_, i) => Math.sin(Math.abs(hash) + i * 0.1) * 0.1);
        }
      };
    }
  }
  return aiServiceModule;
}

/**
 * Veritabanƒ± yedekleme sistemi
 */
async function createBackup(): Promise<void> {
  try {
    if (!fs.existsSync(BACKUP_DIR)) {
      fs.mkdirSync(BACKUP_DIR, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(BACKUP_DIR, `database_backup_${timestamp}.sqlite`);
    
    if (fs.existsSync(SQLITE_PATH)) {
      fs.copyFileSync(SQLITE_PATH, backupPath);
      console.log(`üíæ Database backup created: ${backupPath}`);
    }
  } catch (error) {
    console.error('‚ùå Backup creation failed:', error);
  }
}

/**
 * Veritabanƒ± saƒülƒ±k kontrol√º
 */
function checkDatabaseHealth(): boolean {
  try {
    if (!sqliteDb) return false;
    
    // Basit bir sorgu √ßalƒ±≈ütƒ±rarak baƒülantƒ±yƒ± test et
    const result = sqliteDb.prepare('SELECT COUNT(*) as count FROM files').get();
    return typeof result.count === 'number';
  } catch (error) {
    console.error('‚ùå Database health check failed:', error);
    return false;
  }
}

/**
 * ‚úÖ D√úZELTME 3: Database schema d√ºzeltildi
 */
export async function setupDatabase(): Promise<boolean> {
  try {
    console.log(`üìÅ Database directory: ${DB_DIR}`);
    
    if (!fs.existsSync(DB_DIR)) {
      fs.mkdirSync(DB_DIR, { recursive: true });
      console.log('üìÅ Created database directory');
    }
    
    // G√ºnl√ºk yedek olu≈ütur
    await createBackup();
    
    // 1. Better-sqlite3'√º dinamik olarak y√ºkle ve kur
    console.log('üì¶ Loading better-sqlite3...');
    try {
      const sqlite3Module = await import('better-sqlite3');
      Database = sqlite3Module.default;
      console.log('‚úÖ Better-sqlite3 loaded');
      
      console.log('üóÑÔ∏è Setting up SQLite database...');
      sqliteDb = new Database(SQLITE_PATH);
      
      // ‚úÖ D√úZELTME: Geli≈ümi≈ü tablo yapƒ±sƒ± - chunk_count kolonu eklendi
      sqliteDb.exec(`
        CREATE TABLE IF NOT EXISTS files (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          file_path TEXT UNIQUE NOT NULL,
          content_hash TEXT NOT NULL,
          last_indexed INTEGER NOT NULL,
          file_size INTEGER,
          file_type TEXT,
          language TEXT,
          chunk_count INTEGER DEFAULT 0,
          created_at INTEGER DEFAULT (strftime('%s', 'now')),
          updated_at INTEGER DEFAULT (strftime('%s', 'now'))
        );

        CREATE TABLE IF NOT EXISTS chunks (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          file_path TEXT NOT NULL,
          chunk_id TEXT NOT NULL,
          text_content TEXT NOT NULL,
          file_type TEXT,
          language TEXT,
          created_at INTEGER DEFAULT (strftime('%s', 'now')),
          UNIQUE(file_path, chunk_id)
        );

        CREATE TABLE IF NOT EXISTS search_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          query TEXT NOT NULL,
          results_count INTEGER,
          search_type TEXT,
          created_at INTEGER DEFAULT (strftime('%s', 'now'))
        );

        -- ƒ∞ndeksler
        CREATE INDEX IF NOT EXISTS idx_files_path ON files(file_path);
        CREATE INDEX IF NOT EXISTS idx_files_hash ON files(content_hash);
        CREATE INDEX IF NOT EXISTS idx_files_type ON files(file_type);
        CREATE INDEX IF NOT EXISTS idx_chunks_path ON chunks(file_path);
        CREATE INDEX IF NOT EXISTS idx_search_history_query ON search_history(query);
      `);
      
      // ‚úÖ D√úZELTME: Eksik chunk_count kolonu kontrol√º ve eklenmesi
      try {
        sqliteDb.prepare('SELECT chunk_count FROM files LIMIT 1').get();
        console.log('‚úÖ chunk_count column exists');
      } catch (error) {
        console.log('üîß Adding missing chunk_count column...');
        sqliteDb.exec('ALTER TABLE files ADD COLUMN chunk_count INTEGER DEFAULT 0');
        console.log('‚úÖ chunk_count column added');
      }
      
      console.log('‚úÖ SQLite database ready with enhanced schema');
      
    } catch (error) {
      console.error('‚ùå SQLite setup failed:', error);
      console.log('üìù Continuing without SQLite...');
      sqliteDb = null;
    }
    
    // 2. LanceDB'yi dinamik olarak y√ºkle
    console.log('üì¶ Loading LanceDB...');
    try {
      const lancedbModule = await import('@lancedb/lancedb');
      lancedb = lancedbModule.default || lancedbModule;
      console.log('‚úÖ LanceDB loaded');
      
      console.log('üîç Setting up LanceDB vector database...');
      const lancedbConnection = await lancedb.connect(DB_DIR);
      
      try {
        vectorTable = await lancedbConnection.openTable('file_vectors');
        console.log("‚úÖ Existing 'file_vectors' table opened");
      } catch (e) {
        console.log("üìù Creating new 'file_vectors' table...");
        
        const sampleData = [{
          vector: Array(768).fill(0.1),
          text: 'sample text',
          path: 'sample/path.txt',
          chunk_id: 'sample_chunk_0',
          file_type: 'text',
          language: 'unknown',
          created_at: Date.now()
        }];
        
        vectorTable = await lancedbConnection.createTable('file_vectors', sampleData);
        console.log('‚úÖ New vector table created with enhanced schema');
      }
      
    } catch (error) {
      console.error('‚ùå LanceDB setup failed:', error);
      console.log('üìù Continuing without LanceDB...');
      lancedb = null;
      vectorTable = null;
    }
    
    isInitialized = true;
    
    if (sqliteDb && vectorTable) {
      console.log('üéâ Database setup completed successfully! (SQLite + LanceDB)');
      return true;
    } else if (sqliteDb) {
      console.log('üéâ Database setup completed! (SQLite only)');
      return true;
    } else if (vectorTable) {
      console.log('üéâ Database setup completed! (LanceDB only)');
      return true;
    } else {
      console.log('‚ö†Ô∏è Database setup completed with limitations (No databases available)');
      return false;
    }
    
  } catch (error) {
    console.error('üí• Database setup error:', error);
    throw error;
  }
}

/**
 * G√ºvenli SQLite baƒülantƒ±sƒ± al
 */
export const getSqliteDb = () => {
  if (!sqliteDb) {
    throw new Error('SQLite database not initialized.');
  }
  if (!checkDatabaseHealth()) {
    throw new Error('SQLite database health check failed.');
  }
  return sqliteDb;
};

/**
 * Dosya t√ºr√ºn√º belirle
 */
function detectFileType(filePath: string): { type: string; language: string } {
  const ext = path.extname(filePath).toLowerCase();
  const fileName = path.basename(filePath).toLowerCase();
  
  const typeMap: { [key: string]: { type: string; language: string } } = {
    '.js': { type: 'code', language: 'javascript' },
    '.ts': { type: 'code', language: 'typescript' },
    '.jsx': { type: 'code', language: 'react' },
    '.tsx': { type: 'code', language: 'react-typescript' },
    '.py': { type: 'code', language: 'python' },
    '.java': { type: 'code', language: 'java' },
    '.cpp': { type: 'code', language: 'cpp' },
    '.c': { type: 'code', language: 'c' },
    '.cs': { type: 'code', language: 'csharp' },
    '.php': { type: 'code', language: 'php' },
    '.rb': { type: 'code', language: 'ruby' },
    '.go': { type: 'code', language: 'go' },
    '.rs': { type: 'code', language: 'rust' },
    '.json': { type: 'data', language: 'json' },
    '.xml': { type: 'data', language: 'xml' },
    '.yaml': { type: 'config', language: 'yaml' },
    '.yml': { type: 'config', language: 'yaml' },
    '.md': { type: 'documentation', language: 'markdown' },
    '.txt': { type: 'text', language: 'plain' },
    '.html': { type: 'markup', language: 'html' },
    '.css': { type: 'style', language: 'css' },
    '.sql': { type: 'database', language: 'sql' }
  };
  
  if (typeMap[ext]) {
    return typeMap[ext];
  }
  
  // Uzantƒ±sƒ±z dosyalar i√ßin
  if (fileName.includes('dockerfile')) return { type: 'config', language: 'docker' };
  if (fileName.includes('makefile')) return { type: 'build', language: 'makefile' };
  if (fileName.includes('readme')) return { type: 'documentation', language: 'markdown' };
  
  return { type: 'unknown', language: 'unknown' };
}

/**
 * ‚úÖ D√úZELTME 4: Geli≈ümi≈ü dosya metadata kaydetme - chunk_count parametresi eklendi
 */
export function saveFileMetadata(filePath: string, contentHash: string, fileSize: number, chunkCount: number = 0): void {
  try {
    if (!sqliteDb) {
      console.log(`‚è≠Ô∏è Skipping metadata save (SQLite not available): ${path.basename(filePath)}`);
      return;
    }
    
    const { type, language } = detectFileType(filePath);
    const db = getSqliteDb();
    
    const stmt = db.prepare(`
      INSERT OR REPLACE INTO files 
      (file_path, content_hash, last_indexed, file_size, file_type, language, chunk_count, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(filePath, contentHash, Date.now(), fileSize, type, language, chunkCount, Date.now());
    console.log(`üíæ Saved metadata for: ${path.basename(filePath)} (${type}/${language}, ${chunkCount} chunks)`);
  } catch (error) {
    console.error('‚ùå Error saving metadata:', error);
  }
}

/**
 * Dosya indeks kontrol√º
 */
export function isFileIndexed(filePath: string, contentHash: string): boolean {
  try {
    if (!sqliteDb) {
      console.log(`‚è≠Ô∏è Cannot check if indexed (SQLite not available): ${path.basename(filePath)}`);
      return false;
    }
    
    const db = getSqliteDb();
    const stmt = db.prepare('SELECT content_hash, last_indexed FROM files WHERE file_path = ?');
    const result = stmt.get(filePath);
    
    if (!result) return false;
    
    // Hash e≈üle≈ümesi ve 24 saatten eski deƒüilse
    const dayAgo = Date.now() - (24 * 60 * 60 * 1000);
    return result.content_hash === contentHash && result.last_indexed > dayAgo;
  } catch (error) {
    console.error('‚ùå Error checking if file indexed:', error);
    return false;
  }
}

/**
 * ‚úÖ D√úZELTME 5: Metin chunk ekleme - AI service import d√ºzeltildi
 */
export async function addTextChunk(text: string, filePath: string, chunkId: string): Promise<void> {
  try {
    console.log(`üìù Adding text chunk: ${path.basename(filePath)} - ${chunkId}`);
    
    // SQLite'a chunk bilgisini kaydet
    if (sqliteDb) {
      const db = getSqliteDb();
      const { type, language } = detectFileType(filePath);
      
      // Chunk'ƒ± kaydet
      const stmt = db.prepare(`
        INSERT OR REPLACE INTO chunks 
        (file_path, chunk_id, text_content, file_type, language)
        VALUES (?, ?, ?, ?, ?)
      `);
      
      stmt.run(filePath, chunkId, text, type, language);
      console.log(`‚úÖ Chunk saved to SQLite: ${chunkId}`);
    }
    
    // Vector DB'ye eklemeyi dene (opsiyonel)
    if (vectorTable) {
      try {
        const { type, language } = detectFileType(filePath);
        const aiService = await getAIService();
        
        // ‚úÖ D√úZELTME: Doƒüru AI service √ßaƒürƒ±sƒ±
        const vector = await aiService.getEmbedding(text);
        
        await vectorTable.add([{
          vector,
          text,
          path: filePath,
          chunk_id: chunkId,
          file_type: type,
          language: language,
          created_at: Date.now()
        }]);
        
        console.log(`‚úÖ Added to vector DB: ${chunkId}`);
      } catch (vectorError) {
        console.log(`‚ö†Ô∏è Vector DB skip: ${vectorError}`);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Error adding text chunk:', error);
  }
}

/**
 * Veritabanƒ± istatistikleri al
 */
export function getDatabaseStats(): DatabaseStats {
  try {
    if (!sqliteDb) {
      return {
        total_files: 0,
        total_chunks: 0,
        last_updated: 'N/A',
        database_size: '0 MB',
        indexed_extensions: []
      };
    }
    
    const db = getSqliteDb();
    
    const fileCount = db.prepare('SELECT COUNT(*) as count FROM files').get();
    const chunkCount = db.prepare('SELECT COUNT(*) as count FROM chunks').get();
    const lastUpdate = db.prepare('SELECT MAX(last_indexed) as last FROM files').get();
    const extensions = db.prepare('SELECT DISTINCT file_type FROM files WHERE file_type IS NOT NULL').all();
    
    const dbSize = fs.existsSync(SQLITE_PATH) ? 
      (fs.statSync(SQLITE_PATH).size / (1024 * 1024)).toFixed(2) + ' MB' : '0 MB';
    
    return {
      total_files: fileCount.count || 0,
      total_chunks: chunkCount.count || 0,
      last_updated: lastUpdate.last ? new Date(lastUpdate.last).toLocaleString() : 'Never',
      database_size: dbSize,
      indexed_extensions: extensions.map((e: any) => e.file_type)
    };
  } catch (error) {
    console.error('‚ùå Error getting database stats:', error);
    return {
      total_files: 0,
      total_chunks: 0,
      last_updated: 'Error',
      database_size: '0 MB',
      indexed_extensions: []
    };
  }
}

/**
 * Geli≈ümi≈ü benzerlik aramasƒ±
 */
export async function searchNotesBySimilarity(query: string): Promise<SearchResult[]> {
  try {
    console.log(`üîç Enhanced searching for: "${query}"`);
    
    if (!sqliteDb) {
      console.log('‚ùå No SQLite database available');
      return [{ path: 'no-db.txt', text: 'SQLite database not available' }];
    }

    const db = getSqliteDb();
    const allFiles = db.prepare('SELECT COUNT(*) as count FROM files').get();
    
    console.log(`üìä Total files in database: ${allFiles.count}`);
    
    if (allFiles.count === 0) {
      return [{ 
        path: 'no-files.txt', 
        text: '‚ùå Veritabanƒ±nda hi√ß dosya yok. √ñnce indexleme yapƒ±n.',
        type: 'error'
      }];
    }
    
    // Geli≈ümi≈ü arama stratejisi
    let fileResults: FileResult[] = [];
    const lowerQuery = query.toLowerCase();
    
    // 1. Dosya adƒ±nda tam e≈üle≈üme
    console.log('üéØ Phase 1: Exact filename match');
    const exactStmt = db.prepare(`
      SELECT file_path as path, file_size, file_type, language,
             datetime(last_indexed/1000, 'unixepoch') as indexed_date
      FROM files 
      WHERE LOWER(file_path) LIKE ? 
      ORDER BY last_indexed DESC 
      LIMIT 5
    `);
    
    fileResults = exactStmt.all(`%${lowerQuery}%`) as FileResult[];
    console.log(`üìã Exact matches: ${fileResults.length}`);
    
    // 2. Dosya t√ºr√ºne g√∂re arama
    if (fileResults.length < 3) {
      console.log('üîç Phase 2: File type search');
      const typeStmt = db.prepare(`
        SELECT file_path as path, file_size, file_type, language,
               datetime(last_indexed/1000, 'unixepoch') as indexed_date
        FROM files 
        WHERE file_type LIKE ? OR language LIKE ?
        ORDER BY last_indexed DESC 
        LIMIT 10
      `);
      
      const typeResults = typeStmt.all(`%${lowerQuery}%`, `%${lowerQuery}%`) as FileResult[];
      fileResults = [...fileResults, ...typeResults];
    }
    
    // 3. Genel arama
    if (fileResults.length < 5) {
      console.log('üîç Phase 3: General search');
      const generalStmt = db.prepare(`
        SELECT file_path as path, file_size, file_type, language,
               datetime(last_indexed/1000, 'unixepoch') as indexed_date
        FROM files 
        ORDER BY 
          CASE 
            WHEN LOWER(file_path) LIKE ? THEN 1
            WHEN file_type IN ('code', 'documentation') THEN 2
            ELSE 3
          END,
          last_indexed DESC 
        LIMIT 15
      `);
      
      const generalResults = generalStmt.all(`%${lowerQuery}%`) as FileResult[];
      fileResults = [...fileResults, ...generalResults];
    }
    
    // Duplikasyonlarƒ± temizle
    const uniqueResults = fileResults.filter((result, index, self) => 
      index === self.findIndex(r => r.path === result.path)
    ).slice(0, 10);
    
    // ƒ∞√ßerik analizi ve sonu√ß olu≈üturma
    const resultsWithContent: SearchResult[] = [];
    
    for (const fileResult of uniqueResults) {
      console.log(`üìÑ Processing file: ${fileResult.path}`);
      
      try {
        if (fs.existsSync(fileResult.path)) {
          const content = fs.readFileSync(fileResult.path, 'utf8');
          const fileName = path.basename(fileResult.path);
          
          let preview = '';
          const lowerContent = content.toLowerCase();
          
          if (lowerContent.includes(lowerQuery) || fileName.toLowerCase().includes(lowerQuery)) {
            // Relevantlƒ±k skoru hesapla
            const titleMatch = fileName.toLowerCase().includes(lowerQuery) ? 10 : 0;
            const contentMatches = (lowerContent.match(new RegExp(lowerQuery, 'g')) || []).length;
            const relevanceScore = titleMatch + contentMatches;
            
            // ƒ∞lgili satƒ±rlarƒ± bul
            const lines = content.split('\n');
            const relevantLines = lines.filter(line => 
              line.toLowerCase().includes(lowerQuery) || 
              line.includes('interface') || 
              line.includes('class') || 
              line.includes('function') ||
              line.includes('export') ||
              line.includes('import')
            ).slice(0, 15);
            
            if (relevantLines.length > 0) {
              preview = relevantLines.join('\n');
            } else {
              preview = content.substring(0, 600) + '...';
            }
            
            resultsWithContent.push({
              path: fileResult.path,
              text: `üìÑ ${fileName} (${fileResult.file_type}/${fileResult.language})\n\n${preview}`,
              file_size: fileResult.file_size,
              indexed_date: fileResult.indexed_date,
              file_type: fileResult.file_type,
              language: fileResult.language,
              relevance_score: relevanceScore
            });
          } else {
            preview = content.substring(0, 400) + '...';
            
            resultsWithContent.push({
              path: fileResult.path,
              text: `üìÑ ${fileName} (${fileResult.file_type}/${fileResult.language})\n\n${preview}`,
              file_size: fileResult.file_size,
              indexed_date: fileResult.indexed_date,
              file_type: fileResult.file_type,
              language: fileResult.language,
              relevance_score: 1
            });
          }
          
          console.log(`‚úÖ Added content for: ${fileName}`);
        } else {
          console.log(`‚ùå File not found: ${fileResult.path}`);
        }
      } catch (error) {
        console.error(`‚ùå Error reading file ${fileResult.path}:`, error);
      }
    }
    
    // Relevansa g√∂re sƒ±rala
    resultsWithContent.sort((a, b) => (b.relevance_score || 0) - (a.relevance_score || 0));
    
    if (resultsWithContent.length > 0) {
      return resultsWithContent;
    }
    
    return [
      { 
        path: 'no-results.txt', 
        text: `üîç "${query}" i√ßin dosya bulunamadƒ±.\n\nüìä Veritabanƒ±nda ${allFiles.count} dosya var.\n\nDeneyebileceƒüiniz:\nüìÅ Tam dosya adƒ± (√∂rn: "database.ts")\nüìÅ Dosya t√ºr√º (√∂rn: "code", "documentation")\nüìÅ Programlama dili (√∂rn: "typescript", "javascript")\nüìÅ Kod par√ßasƒ± (√∂rn: "function", "class")`,
        type: 'help'
      }
    ];
    
  } catch (error) {
    console.error('üîç Enhanced search error:', error);
    return [
      { 
        path: 'error.txt', 
        text: `‚ùå Arama hatasƒ±: ${error instanceof Error ? error.message : String(error)}`,
        type: 'error'
      }
    ];
  }
}

/**
 * Hƒ±zlƒ± klas√∂r indexleme
 */
async function quickIndexFolder(folderPath: string): Promise<string> {
  try {
    let cleanPath = folderPath
      .replace(/"|'/g, '')
      .replace(/‚îú√Çr/g, '√∂r')
      .replace(/‚îúƒü/g, 'ƒü')
      .trim();
    
    console.log(`üîç Original path: "${folderPath}"`);
    console.log(`üßπ Cleaned path: "${cleanPath}"`);
    
    let normalizedPath = cleanPath;
    
    if (!path.isAbsolute(cleanPath)) {
      const homeDir = require('os').homedir();
      const possiblePaths = [
        path.join(homeDir, 'Desktop', cleanPath),
        path.join(homeDir, 'Documents', cleanPath),
        path.join(homeDir, 'Downloads', cleanPath),
        path.join(homeDir, 'Projects', cleanPath),
        path.join(homeDir, 'Code', cleanPath),
        path.join(homeDir, 'Development', cleanPath),
        path.join(homeDir, cleanPath)
      ];
      
      console.log(`üîç Searching in these paths:`);
      possiblePaths.forEach(p => console.log(`  - ${p}`));
      
      for (const possiblePath of possiblePaths) {
        if (fs.existsSync(possiblePath)) {
          normalizedPath = possiblePath;
          console.log(`‚úÖ Found folder at: ${normalizedPath}`);
          break;
        }
      }
    }
    
    if (!fs.existsSync(normalizedPath)) {
      return `‚ùå Klas√∂r bulunamadƒ±: "${cleanPath}"\n\nüîç Aranan yerler:\n${[
        path.join(require('os').homedir(), 'Desktop', cleanPath),
        path.join(require('os').homedir(), 'Documents', cleanPath),
        path.join(require('os').homedir(), 'Downloads', cleanPath)
      ].map(p => `  ‚Ä¢ ${p}`).join('\n')}`;
    }
    
    if (!fs.statSync(normalizedPath).isDirectory()) {
      return `‚ùå Bu bir klas√∂r deƒüil: ${cleanPath}`;
    }
    
    console.log(`üöÄ Quick indexing folder: ${normalizedPath}`);
    
    const startTime = Date.now();
    const fileService = await import('./file-service');
    await fileService.indexFiles(normalizedPath, true);
    const endTime = Date.now();
    
    if (sqliteDb) {
      const db = getSqliteDb();
      const count = db.prepare('SELECT COUNT(*) as count FROM files WHERE file_path LIKE ?').get(`${normalizedPath}%`);
      const duration = ((endTime - startTime) / 1000).toFixed(2);
      
      return `‚úÖ Klas√∂r indexlendi: ${normalizedPath}\nüìä ${count.count} dosya i≈ülendi\n‚è±Ô∏è S√ºre: ${duration} saniye`;
    }
    
    return `‚úÖ Klas√∂r indexlendi: ${normalizedPath}`;
    
  } catch (error) {
    console.error('Quick index error:', error);
    return `‚ùå ƒ∞ndexleme hatasƒ±: ${error instanceof Error ? error.message : String(error)}`;
  }
}

/**
 * Akƒ±llƒ± hibrit arama - En geli≈ümi≈ü versiyon
 */
export async function smartHybridSearch(query: string): Promise<SearchResult[]> {
  try {
    console.log(`üß† Smart hybrid search for: "${query}"`);
    
    const lowerQuery = query.toLowerCase();
    
    // Klas√∂r indexleme komutlarƒ±
    if (lowerQuery.includes('klas√∂r:') || lowerQuery.includes('folder:') || lowerQuery.includes('index:')) {
      const folderPath = query.split(':')[1]?.trim();
      if (folderPath) {
        const indexResult = await quickIndexFolder(folderPath);
        return [{
          path: 'üìÅ Klas√∂r ƒ∞ndexleme Sonucu',
          text: indexResult,
          type: 'index_result'
        }];
      }
    }
    
    // ƒ∞statistik komutlarƒ±
    if (lowerQuery.includes('istatistik') || lowerQuery.includes('stats')) {
      const stats = getDatabaseStats();
      return [{
        path: 'üìä Veritabanƒ± ƒ∞statistikleri',
        text: `üìà Singleton Database Analytics

üìÅ DOSYA ƒ∞STATƒ∞STƒ∞KLERƒ∞:
‚Ä¢ Toplam Dosya: ${stats.total_files.toLocaleString()}
‚Ä¢ Toplam Chunk: ${stats.total_chunks.toLocaleString()}
‚Ä¢ Son G√ºncelleme: ${stats.last_updated}
‚Ä¢ Veritabanƒ± Boyutu: ${stats.database_size}

üìÇ DOSYA Tƒ∞PLERƒ∞:
${stats.indexed_extensions.length > 0 ? 
  stats.indexed_extensions.map(ext => `‚Ä¢ ${ext.charAt(0).toUpperCase() + ext.slice(1)}`).join('\n') :
  '‚Ä¢ Hen√ºz dosya indexlenmemi≈ü'
}

üîß Sƒ∞STEM DURUMU:
‚Ä¢ SQLite: ${sqliteDb ? '‚úÖ Aktif' : '‚ùå Pasif'}
‚Ä¢ LanceDB: ${vectorTable ? '‚úÖ Aktif' : '‚ùå Pasif'}
‚Ä¢ Database Health: ${checkDatabaseHealth() ? '‚úÖ Saƒülƒ±klƒ±' : '‚ö†Ô∏è Problem Var'}`,
        type: 'stats'
      }];
    }
    
    // Yardƒ±m komutlarƒ±
    if (lowerQuery.includes('yardƒ±m') || lowerQuery.includes('help') || query === '?') {
      return [{
        path: '‚ùì Yardƒ±m Kƒ±lavuzu',
        text: `üöÄ Singleton AI Kod M√ºhendisi - Kullanƒ±m Kƒ±lavuzu

üìÅ KLAS√ñR ƒ∞≈ûLEMLERƒ∞:
‚Ä¢ "klas√∂r: proje_adƒ±" - Klas√∂r indexle
‚Ä¢ "folder: C:\\path\\to\\folder" - Tam yol ile indexle

üîç ARAMA Y√ñNTEMLERƒ∞:
‚Ä¢ "database kodunu g√∂ster" - Kod dosyasƒ± ara
‚Ä¢ "typescript interface" - Kod yapƒ±sƒ± ara
‚Ä¢ "error handler" - Fonksiyon ara

üìä Sƒ∞STEM KOMUTLARI:
‚Ä¢ "istatistik" - Veritabanƒ± bilgileri
‚Ä¢ "yardƒ±m" - Bu mesajƒ± g√∂ster

üí° ƒ∞PU√áLARI:
‚Ä¢ T√ºrk√ße ve ƒ∞ngilizce arama desteklenir
‚Ä¢ Dosya adlarƒ± tam olarak yazƒ±lmalƒ±dƒ±r
‚Ä¢ B√ºy√ºk-k√º√ß√ºk harf duyarlƒ± deƒüildir`,
        type: 'help'
      }];
    }
    
    // Normal arama
    return await searchNotesBySimilarity(query);
    
  } catch (error) {
    console.error('üß† Smart hybrid search error:', error);
    return [
      { 
        path: 'error.txt', 
        text: `‚ùå Akƒ±llƒ± arama hatasƒ±: ${error instanceof Error ? error.message : String(error)}`,
        type: 'error'
      }
    ];
  }
}

/**
 * Veritabanƒ±nƒ± g√ºvenli ≈üekilde kapat
 */
export function closeDatabase(): void {
  try {
    if (sqliteDb) {
      sqliteDb.close();
      sqliteDb = null;
      console.log('‚úÖ SQLite database closed');
    }
    
    if (vectorTable) {
      vectorTable = null;
      console.log('‚úÖ Vector database connection closed');
    }
    
    isInitialized = false;
  } catch (error) {
    console.error('‚ùå Error closing database:', error);
  }
}

// Process kapanƒ±rken veritabanƒ±nƒ± temizle
process.on('beforeExit', () => {
  closeDatabase();
});

process.on('SIGINT', () => {
  closeDatabase();
  process.exit(0);
});

process.on('SIGTERM', () => {
  closeDatabase();
  process.exit(0);
});
